<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-PDF OCR and Data Structuring Demo</title>
    <script src="https://unpkg.com/tesseract.js@v6.0.0/dist/tesseract.min.js"></script>
    <script src="https://mozilla.github.io/pdf.js/build/pdf.mjs" type="module"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        #result, #log, #structured-data {
            margin-top: 20px;
            white-space: pre-wrap;
            border: 1px solid #ccc;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        #log {
            background-color: #f0f0f0;
            font-family: monospace;
        }

        #pdf-images {
            display: flex;
            overflow-x: auto;
            white-space: nowrap;
            margin-top: 20px;
        }

        .pdf-image {
            max-width: 1000px;
            max-height: 1000px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
<h1>Receipt OCR to Money Manager</h1>
<form id="upload-form">
    <input type="file" id="file-input" accept=".pdf, image/jpeg, image/png" multiple required>
    <button type="submit">Process Files</button>
</form>
<h2>Log:</h2>
<div id="log"></div>
<h2>PDF Previews:</h2>
<div id="pdf-images"></div>
<h2>OCR Result:</h2>
<div id="result"></div>
<h2>Parsed Data:</h2>
<div id="structured-data"></div>

<script type="module">
    const form = document.getElementById('upload-form');
    const fileInput = document.getElementById('file-input');
    const resultDiv = document.getElementById('result');
    const logDiv = document.getElementById('log');
    const pdfImagesDiv = document.getElementById('pdf-images');
    const structuredDataDiv = document.getElementById('structured-data');

    const {pdfjsLib} = globalThis;
    pdfjsLib.GlobalWorkerOptions.workerSrc = '//mozilla.github.io/pdf.js/build/pdf.worker.mjs';


    function log(message) {
        const timestamp = new Date().toISOString();
        logDiv.innerHTML += `[${timestamp}] ${message}\n`;
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(`[${timestamp}] ${message}`);
    }

    async function convertPdfToImage(pdfFile) {
        log(`Starting PDF to image conversion for ${pdfFile.name}`);
        const arrayBuffer = await pdfFile.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        log(`PDF loaded, number of pages: ${pdf.numPages}`);

        const page = await pdf.getPage(1);
        const scale = 1.5;
        const viewport = page.getViewport({scale});

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        const renderContext = {
            canvasContext: context,
            viewport: viewport
        };

        log('Rendering PDF page to canvas');
        await page.render(renderContext).promise;
        log('PDF page rendered to canvas');

        return new Promise((resolve) => {
            canvas.toBlob((blob) => {
                log('Canvas converted to blob');
                resolve(blob);
            }, 'image/png');
        });
    }

    async function processFiles(file) {
        let allText = '';
        let imageBlob = file;

        if (file.type === 'application/pdf') {
            log(`Processing PDF: ${file.name}`);
            imageBlob = await convertPdfToImage(file);
        } else if (!file.type.startsWith('image/')) {
            alert('file type not supported');
        }

        const img = document.createElement('img');
        img.src = URL.createObjectURL(imageBlob);
        img.className = 'pdf-image';
        pdfImagesDiv.appendChild(img);

        log('Starting Tesseract.js recognition');
        const result = await Tesseract.recognize(imageBlob, 'swe', {
            langPath: 'https://tessdata.projectnaptha.com/4.0.0_best/',
            logger: m => log(`Tesseract progress: ${m.status} (${(m.progress * 100).toFixed(2)}%)`)
        });
        log('Tesseract.js recognition completed');
        allText += result.data.text + '\n\n';

        const ocrResult = document.createElement('p');
        ocrResult.textContent = allText;
        resultDiv.appendChild(ocrResult);
        log(`Total OCR result length: ${allText.length} characters`);

        return allText;
    }

    function parseLidlOCRResult(text) {
        const lines = text.split('\n');
        const result = [];
        let currentItem = null;
        let i = 0;

        while (i < lines.length) {
            const line = lines[i].trim();
            const priceMatch = line.match(/(\d+[.,]\d+)\s*C$/);

            if (priceMatch) {
                if (currentItem) {
                    result.push(currentItem);
                }

                const price = parseFloat(priceMatch[1].replace(',', '.'));
                const name = line.substring(0, line.indexOf(priceMatch[1])).trim();
                currentItem = {name, price, extraInfo: ''};

                // Look for discounts or extra info in the next lines
                let j = i + 1;
                while (j < lines.length) {
                    const nextLine = lines[j].trim();
                    const discountMatch = nextLine.match(/-(\d+[.,]\d+)/);

                    if (discountMatch) {
                        const discount = parseFloat(discountMatch[1].replace(',', '.'));
                        currentItem.price -= discount;
                    } else if (nextLine.includes('SEK/kg')) {
                        currentItem.extraInfo = nextLine;
                    } else if (nextLine.match(/(\d+[.,]\d+)\s*C$/)) {
                        // Next item found, break the inner loop
                        break;
                    }
                    j++;
                }
                i = j - 1; // Set the outer loop to continue from where we left off
            }
            i++;
        }

        // Add the last item if exists
        if (currentItem) {
            result.push(currentItem);
        }

        const dateRegex = /\d{4}\/\d{2}\/\d{2}/;
        const match = text.match(dateRegex);
        if (!match) {
            log('Date not found in the OCR text');
        }

        const dateString = match[0];
        // Note: JavaScript interprets date strings in UTC by default
        const date = new Date(dateString);
        return {
            transaction_date: date.toISOString(),
            items: result
        };
    }

    function parseWillysOcrResult(ocrText) {
        let items = [];
        let transactionDate = '';

        const lines = ocrText.trim().split('\n');
        const itemRegex = /^(.+)\s(-?\d+,\d{2})$/;
        const discountRegex = /^(.+)\s(-\d+,\d{2})$/;
        const dateRegex = /(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2})$/;
        const endOfItemsRegex = /^Totalt.*/;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            const itemMatch = line.match(itemRegex);
            const discountMatch = line.match(discountRegex);
            const endOfItemsMatch = line.match(endOfItemsRegex);

            if (itemMatch) {
                items.push({
                    name: itemMatch[1].trim(),
                    price: parseFloat(itemMatch[2].replace(',', '.'))
                });
            } else if (discountMatch) {
                // subtract the discount from the last item
                items[items.length - 1].price += parseFloat(discountMatch[2].replace(',', '.'));
            } else if (endOfItemsMatch) {
                break;
            }
        }
        const dateMatch = lines[lines.length - 1].match(dateRegex);
        if (dateMatch) {
            transactionDate = new Date(dateMatch[1]);
        } else {
            log('Date not found in the OCR text');
        }

        // validate the total price
        const totalPriceRegex = /Totalt ([\d,]+) SEK/
        log('Checking total price');
        const amountMatch = ocrText.match(totalPriceRegex);
        const totalAmount = amountMatch ? amountMatch[1] : null;
        log(`Total amount: ${totalAmount}`);

        if (totalAmount) {
            const calculatedTotal = items.reduce((acc, item) => acc + item.price, 0);
            if (calculatedTotal.toFixed(2) !== parseFloat(totalAmount.replace(',', '.')).toFixed(2)) {
                log(`Total amount mismatch: expected ${totalAmount}, got ${calculatedTotal.toFixed(2)}`);
            }
        }
        return {
            transaction_date: transactionDate,
            items: items
        };
    }

    function structureData(ocrText) {
        const willysRegex = /Willys/;
        const lidlRegex = /lidl.se/;

        if (ocrText.match(willysRegex)) {
            return parseWillysOcrResult(ocrText);
        } else if (ocrText.match(lidlRegex)) {
            return parseLidlOCRResult(ocrText);
        } else {
            return {error: 'Unknown store'};
        }
    }

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        resultDiv.textContent = '';
        pdfImagesDiv.innerHTML = '';
        const files = fileInput.files;

        if (files.length > 0) {
            try {
                let json_results = [];

                for (const file of files) {
                    const ocrText = await processFiles(file);
                    const structuredData = structureData(ocrText);
                    json_results.push(structuredData);
                }

                structuredDataDiv.textContent = JSON.stringify(json_results, null, 2);
                log('Data structuring completed');
            } catch (error) {
                log(`Error processing files: ${error.message}`);
                resultDiv.textContent = 'Error processing files: ' + error.message;
            }
        } else {
            log('No files selected for processing');
        }
    });

    log('Page loaded and ready');
</script>
</body>
</html>